// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64

package bpfprocess

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type bpfProcessEvent struct {
	Pid       uint32
	Tgid      uint32
	Uid       uint32
	Euid      uint32
	Gid       uint32
	Egid      uint32
	Ppid      uint32
	Ptgid     uint32
	Puid      uint32
	Peuid     uint32
	Pgid      uint32
	Pegid     uint32
	CurrIndex uint32
	CommIndex uint32
	ExecIndex uint32
	Buffer    [1024]uint8
}

type bpfStringLpmTrie struct {
	Prefixlen uint32
	Data      [256]uint8
}

// loadBpf returns the embedded CollectionSpec for bpf.
func loadBpf() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_BpfBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load bpf: %w", err)
	}

	return spec, err
}

// loadBpfObjects loads bpf and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*bpfObjects
//	*bpfPrograms
//	*bpfMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadBpfObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadBpf()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// bpfSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpfSpecs struct {
	bpfProgramSpecs
	bpfMapSpecs
}

// bpfSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpfProgramSpecs struct {
	CreateEvent             *ebpf.ProgramSpec `ebpf:"create_event"`
	KprobeProcForkConnector *ebpf.ProgramSpec `ebpf:"kprobe_proc_fork_connector"`
}

// bpfMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpfMapSpecs struct {
	BufferHeap    *ebpf.MapSpec `ebpf:"buffer_heap"`
	CidHeap       *ebpf.MapSpec `ebpf:"cid_heap"`
	FilenameHeap  *ebpf.MapSpec `ebpf:"filename_heap"`
	FilenameMaps  *ebpf.MapSpec `ebpf:"filename_maps"`
	ProgramsMap   *ebpf.MapSpec `ebpf:"programs_map"`
	RingbufEvents *ebpf.MapSpec `ebpf:"ringbuf_events"`
	TmpHeap       *ebpf.MapSpec `ebpf:"tmp_heap"`
}

// bpfObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpfObjects struct {
	bpfPrograms
	bpfMaps
}

func (o *bpfObjects) Close() error {
	return _BpfClose(
		&o.bpfPrograms,
		&o.bpfMaps,
	)
}

// bpfMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpfMaps struct {
	BufferHeap    *ebpf.Map `ebpf:"buffer_heap"`
	CidHeap       *ebpf.Map `ebpf:"cid_heap"`
	FilenameHeap  *ebpf.Map `ebpf:"filename_heap"`
	FilenameMaps  *ebpf.Map `ebpf:"filename_maps"`
	ProgramsMap   *ebpf.Map `ebpf:"programs_map"`
	RingbufEvents *ebpf.Map `ebpf:"ringbuf_events"`
	TmpHeap       *ebpf.Map `ebpf:"tmp_heap"`
}

func (m *bpfMaps) Close() error {
	return _BpfClose(
		m.BufferHeap,
		m.CidHeap,
		m.FilenameHeap,
		m.FilenameMaps,
		m.ProgramsMap,
		m.RingbufEvents,
		m.TmpHeap,
	)
}

// bpfPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpfPrograms struct {
	CreateEvent             *ebpf.Program `ebpf:"create_event"`
	KprobeProcForkConnector *ebpf.Program `ebpf:"kprobe_proc_fork_connector"`
}

func (p *bpfPrograms) Close() error {
	return _BpfClose(
		p.CreateEvent,
		p.KprobeProcForkConnector,
	)
}

func _BpfClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed bpf_x86_bpfel.o
var _BpfBytes []byte
